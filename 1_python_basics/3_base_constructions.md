### Коротко о главных управляющих конструкциях

Сейчас мы совсем реактивно пройдёмся по самым основным управляющим конструкциям. Гет реди.


### if

Ну, вы все знаете условный оператор, так ведь?

    :::python
    if age < 18:
        print('Никаких тебе сигарет. Ишь чего удумал!')
    else:
        print('Вам синий или красный?')


Есть ещё `elif`, их можно сделать много в одном операторе. Это такой аналог `which` из других языков.


### for

Цикл. Вместо сишного варианта с init, cond и loop выражениями, тут просто итерация по коллекции:

    :::python
    for user in users:
        print user

Иногда надо не пройтись по списку, а выполнить одну и ту же операцию много раз. Тогда хорошо подходит функция
[range](https://docs.python.org/3.5/library/functions.html#func-range). Она возвращает целые числа в заданном промежутке,
поэтому в цикле её можно использовать так:

    :::python
    for level_num in range(10):
        user.levelup()  # пользователь получит десять уровней. Читер!

А вот `break` и `continue` делают то же, что в Паскале и Сях. `break` прерывает выполнение цикла,
`continue` завершает текущую итерацию и переходит к следующей.

Ещё у цикла есть `else`, но про него почти никто не знает. Как он работает можно посмотреть
[в официальной документации](https://docs.python.org/3.5/tutorial/controlflow.html#break-and-continue-statements-and-else-clauses-on-loops).


### def

Начало объявления функции. После него идёт название,
потом – аргументы функции в скобках, двоеточие и тело функции с отступом:

    :::python
    def get_square(value):
        return value ** 2

То, что после `return` – это возвращаемое значение функции.

Функцию создали, вот как её теперь использовать:

    :::python
    print(get_square(2))  # 4
    print(get_square(6))  # 36
    print(get_square('ыыы'))  # всё сломается

А вот пример посложнее, из исходников Девмана. Получает пользователя по айди в Слаке:

    :::python
    def _get_user_by_slack_id(slack_user_id):
        user_email = get_slack_email_for_user(slack_user_id)
        return User.objects.filter(email__iexact=user_email).first()

(вот почему емейл необходим)


### range

Функция очень полезная, поэтому про неё отдельно. `range` генерирует целые числа в заданном диапазоне. Например:

    :::python
    range(10)  # 0..0
    range(5, 10)  # 5..9
    range(5, 10, 2)  # [5, 7, 9] (от пяти до девяти с шагом два)

Фишка этой функции заключается в том, что она не создаёт список со всеми числами.
Вместо этого он вернёт объект, который будет возвращать элементы как только они нужны, по одному.
Поэтому код `range(9999999999999)` не съест всю память.
Этот хитрый объект (Sequence ABC, но об этом потом) можно превратить в список явно:

    :::python
    list(range(9999999999999))

(не советую так делать)


### pass

Блок, который ничего не делает:

    :::python
    for i in range(20):
        pass  # 20 раз сделать ничего. Очень полезно!

Часто используется в начальном коде для заданий: в финальной версии вместо `pass` должен быть настоящий код.
