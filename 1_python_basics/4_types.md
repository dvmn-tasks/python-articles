### Числа

В самом Питоне есть целые, вещественные, и комплексные числа. В стандартной библиотеке есть ещё рациональные и
фиксированной точности.

У целых чисел нет подводных камней: у них нет ограничения по размеру, поддерживают стандартные арифметические действия
и всякое такое.

У вещественных есть подвох: они внутри представлены как тип double в С++. Это значит, что хранятся они как два числа:
мантисса и экспонента. Это удобно, но иногда из-за ошибок округления и накапливаемых погрешностей происходят ужасные вещи.
Чтобы знать, что и как может сломаться, надо прочитать
[статью про ограничение вещественных числах в документации](https://docs.python.org/3.5/tutorial/floatingpoint.html)
(*мастрид*).

Частный, но важный случай: деньги нельзя хранить как вещественное число, только как целое или с фиксированной точностью.
Это кажется очевидным, но многие так делают (некоторые даже в бою). Их всех потом увольняют. Едва ли это совпадение.

[Официальная заметка про численные типы](https://docs.python.org/3.5/library/stdtypes.html#numeric-types-int-float-complex)
короткая и понятная.


### Строки

Со строками в третьем Питоне всё просто: они Юникодные.

Это значит, что всё сделано очень удобно, но чтобы этим всем удобно пользоваться, надо знать, что такое Юникод, кодировки,
байты, вот это всё. Об этом можно узнать, например, из [классного доклада про Юникод в Питоне](https://www.youtube.com/watch?v=sgHbC6udIqc).

Ещё строки можно форматировать, причём несколькими способами. Вот один из них:

    :::python
    name = 'Пётр'
    height = 1.865
    print('Привет, %s! Твой рост – %.2f м.' % (name, height))
    # Привет, Пётр! Твой рост – 1.86 м.

Заметь, что `%s` значит "вывести строку как есть", а `%.2f` значит "вывести вещественное число 
с точностью до третьего знака". На самом деле, есть целый подъязык этого форматирования. Почитай 
[про него в документации](https://docs.python.org/3.1/library/string.html#format-specification-mini-language)
и [более подробную статью](https://pyformat.info/).

И главное: никогда не используй сложение строк для форматирования. Это плохо читается, долго работает и занимает
много места.


### Списки

Всё необходимое для начала работы со списками, есть в разделе ["Основные типы данных"](http://devman.org/encyclopedia/python_basics/python_basics_base_types/).

Тут давайте немного поговорим о list comprehension (по-русски они зовутся списковыми выражениями, но я ни разу не слышал,
чтобы кто-то так говорил).

Часто бывает надо взять исходный список и сформировать из него новый, применив к каждому элементу исходного
какое-то преобразование и как-то отфильтровав. Например, так:

    :::python
    values = [1, 2, 3, 4, 5]
    new_values = []
    for value in values:
        if value % 2:
            new_values.append(value ** 2)

В результате в `new_values` будут только квадраты чётных чисел из исходного списка.
 
Эта операция настолько частая, что для неё есть отдельная конструкция – list comprehension. Выглядит она так:

    :::python
    values = [1, 2, 3, 4, 5]
    new_values = [value ** 2 for value in values if value % 2]

Это та же конструкция, что и в предыдущем примере, просто записанная очень компактно: посредине тот же цикл,
слева – что добавлять в новый список, а справа - фильтр. Фильтр может быть необязательным, кстати.

### Словари

Словарь – это отображение одних элементов в другие. Первые называют ключами, вторые – значениями.

    :::python
    user_info = {'name': 'Иван', 'level': 2}
    print(user_info['name'])  # Иван


Из словаря можно удалять, менять и добавлять в него элементы:

    :::python
    user_info = {'name': 'Иван', 'level': 2}
    user_info['middle_name'] = 'Иванович'
    user_info['name'] = 'Грирогий'
    del user_info['level']
    print(user_info)  # {'middle_name': 'Иванович', 'name': 'Грирогий'}

Важный момент про словари: они хранят только отображение одних элементов в других, а порядок элементов не хранят.
В примере выше `middle_name` был выведен первым, но на это полагаться нельзя.

Ещё у словарей есть несколько важных методов: `keys`, `values` и `items`. Первый возвращает список только ключей, 
второй – список только значений, третий – список пар из ключей и значений. Удобно при итерации по словарю:

    :::python
    user_info = {'name': 'Иван', 'level': 2}
    for key, value in user_info.items():
        print '%s: %s' % (key, value)
    # name: Иван
    # level: 2


### Кортежи

Кортеж выглядит как список, но не совсем. Это скорее структура из C++.
Отличаются от списков тем, что его элементы гетерогенные и тем, что он умеет упаковываться и распаковываться.
Подробнее, например, [в документации](https://docs.python.org/2/tutorial/datastructures.html#tuples-and-sequences).

### Множества

Множество – это математическое множество. В нём все элементы уникальные, можно считать пересечение,
проверять на вхождение и выполнять другие операции с множествами. 

Один из частых случаев применения множеств – удаление дублей из списка:

    :::python
    l = [1, 2, 1, 3, 2]
    print(list(set(l)))  # [1, 2, 3]